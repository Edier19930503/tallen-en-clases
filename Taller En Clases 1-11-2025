Ejercicio 1: Estadísticas básicas de un arreglo — 10 pts
Enunciado:
Lee n (1 ≤ n ≤ 10^5) y luego n enteros. Calcula mínimo, máximo y promedio (double) usando punteros para recorrer el arreglo. Implementa funciones separar lectura y cálculo.
Firmas/Interfaz sugerida:
void leer_arreglo(int *a, size_t n);
void min_max_prom(const int *a, size_t n, int *minv, int *maxv, double *prom);
Ejemplo:
Entrada: 5\n3 8 -1 4 4 → Salida: min=-1 max=8 prom=3.60


#include <iostream>
#include <iomanip>

void leer_arreglo(int *a, size_t n) {
    for (size_t i = 0; i < n; ++i) {
        std::cin >> *(a + i);
    }
}

void min_max_prom(const int *a, size_t n, int *minv, int *maxv, double *prom) {
    *minv = *maxv = *a;
    long long suma = 0;

    for (const int *p = a; p < a + n; ++p) {
        if (*p < *minv) *minv = *p;
        if (*p > *maxv) *maxv = *p;
        suma += *p;
    }

    *prom = static_cast<double>(suma) / n;
}

int main() {
    size_t n;
    std::cin >> n;

    int *arreglo = new int[n];
    leer_arreglo(arreglo, n);

    int minv, maxv;
    double prom;
    min_max_prom(arreglo, n, &minv, &maxv, &prom);

    std::cout << "min=" << minv << " max=" << maxv << " prom=" << std::fixed << std::setprecision(2) << prom << std::endl;

    delete[] arreglo;
    return 0;
}

Ejercicio 2: Rotación circular in-place — 12 pts Enunciado:
Dado un arreglo de n enteros y un desplazamiento k, rota a la derecha k posiciones in-place. Usa una función auxiliar reverse y punteros.
Firmas/Interfaz sugerida:
void reverse(int *a, size_t i, size_t j);
void rotar_derecha(int *a, size_t n, size_t k);
Caso(s) de prueba sugeridos:
1. [1,2,3,4,5], k=2 → [4,5,1,2,3]



#include <stdio.h>

// Se crea funcion  el segmento del arreglo desde índice i hasta j usando punteros
void reverse(int *a, size_t i, size_t j) {
    int *left = a + i;
    int *right = a + j;
    while (left < right) {
        int temp = *left;
        *left = *right;
        *right = temp;
        ++left;
        --right;
    }
}

// Se crea funcion para rotar el arreglo a la derecha k posiciones usando tres reversos
void rotar_derecha(int *a, size_t n, size_t k) {
    if (n == 0) return;
    k %= n;  // Asegura que k no sea mayor que n
 // Paso 1: invertir todo el arreglo
    reverse(a, 0, n - 1);     
// Paso 2: invertir los primeros k elementos
    reverse(a, 0, k - 1);   
// Paso 3: invertir el resto
    reverse(a, k, n - 1);       
}

int main() {
    int a[] = {1, 2, 3, 4, 5};
    size_t n = sizeof(a) / sizeof(a[0]);
    size_t k = 2;

    rotar_derecha(a, n, k);

    // Se muestra resultado
    for (size_t i = 0; i < n; ++i) {
        printf("%d ", a[i]);
    }
    printf("\n");

    return 0;
}




Ejercicio 3: Normalizar cadenas (arreglo de chars) — 12 pts Enunciado:
Lee una línea (≤ 1000 chars) y normalízala: quita espacios duplicados y recorta extremos.
Implementa con punteros (char *src, char *dst) y sin usar strtok.
Firmas/Interfaz sugerida:
size_t normalizar_espacios(const char *in, char *out, size_t outcap);
Ejemplo:
Entrada: " hola mundo C " → Salida: "hola mundo C" (longitud 12)


#include <stdio.h>
#include <ctype.h>

// Se vrea funcion para normalizar la cadena: elimina espacios duplicados y recorta extremos
size_t normalizar_espacios(const char *src, char *dst, size_t outcap) {
    const char *p = src;
    char *q = dst;
    size_t count = 0;

    // Se crea funcion para saltar espacios iniciales
    while (*p && isspace((unsigned char)*p)) {
        ++p;
    }

    int espacio_prev = 0;

    while (*p && count + 1 < outcap) {
        if (isspace((unsigned char)*p)) {
            if (!espacio_prev) {
                *q++ = ' ';
                ++count;
                espacio_prev = 1;
            }
        } else {
            *q++ = *p;
            ++count;
            espacio_prev = 0;
        }
        ++p;
    }

    // se crea funcion para eliminar espacio final si existe
    if (count > 0 && *(q - 1) == ' ') {
        --q;
        --count;
    }

    *q = '\0';  // Terminar la cadena
    return count;
}

int main() {
    char entrada[1001];
    char salida[1001];

    // Leer línea completa
    fgets(entrada, sizeof(entrada), stdin);

    // Normalizar
    size_t longitud = normalizar_espacios(entrada, salida, sizeof(salida));

    // Se muestra resultado
    printf("Resultado: \"%s\" (longitud %zu)\n", salida, longitud);
    return 0;
}



Ejercicio 4: Matriz — suma por filas y columnas — 15 pts Enunciado:
Dada una matriz m×n de enteros, calcula dos arreglos: sumFila[m] y sumCol[n]. Usa funciones y
punteros a punteros (int **mat) o representación lineal (int *mat = malloc(m*n*sizeof(int))).
Firmas/Interfaz sugerida:
int **mat_crear(size_t m, size_t n);
void mat_destruir(int **A, size_t m);
void mat_sumas(int **A, size_t m, size_t n, int *sumF, int *sumC);
Ejemplo:
Entrada:
3 4
1 2 3 4
5 6 7 8
9 0 1 2
Salida:
sumF: [10,26,12]
sumC: [15,8,11,14]



#include <stdio.h>
#include <stdlib.h>

// Se crea una matriz dinámica de m filas y n columnas
int **mat_crear(size_t m, size_t n) {
    int **A = malloc(m * sizeof(int *));
    if (A == NULL) return NULL;

    for (size_t i = 0; i < m; ++i) {
        A[i] = malloc(n * sizeof(int));
        if (A[i] == NULL) {
            // Liberar lo que se haya asignado si falla
            for (size_t j = 0; j < i; ++j) free(A[j]);
            free(A);
            return NULL;
        }
    }
    return A;
}

// Se crea funcion para liberar la memoria de la matriz
void mat_destruir(int **A, size_t m) {
    for (size_t i = 0; i < m; ++i) {
        free(A[i]);
    }
    free(A);
}

//Se calcula las sumas por fila y por columna
void mat_sumas(int **A, size_t m, size_t n, int *sumF, int *sumC) {
    //Se Inicializa sumas
    for (size_t i = 0; i < m; ++i) sumF[i] = 0;
    for (size_t j = 0; j < n; ++j) sumC[j] = 0;

    //Se Recorre la matriz usando punteros
    for (size_t i = 0; i < m; ++i) {
        for (size_t j = 0; j < n; ++j) {
            int val = A[i][j];
            sumF[i] += val;
            sumC[j] += val;
        }
    }
}

int main() {
    size_t m, n;
    scanf("%zu %zu", &m, &n);

    int **mat = mat_crear(m, n);
    if (mat == NULL) {
        fprintf(stderr, "Error al crear la matriz\n");
        return 1;
    }

    //Se crea la funcion para leer la matriz
    for (size_t i = 0; i < m; ++i) {
        for (size_t j = 0; j < n; ++j) {
            scanf("%d", &mat[i][j]);
        }
    }

    // Crear arreglos para las sumas
    int *sumF = malloc(m * sizeof(int));
    int *sumC = malloc(n * sizeof(int));

    mat_sumas(mat, m, n, sumF, sumC);

    // Se muestra resultados
    printf("sumF: [");
    for (size_t i = 0; i < m; ++i) {
        printf("%d%s", sumF[i], (i < m - 1) ? "," : "");
    }
    printf("]\n");

    printf("sumC: [");
    for (size_t j = 0; j < n; ++j) {
        printf("%d%s", sumC[j], (j < n - 1) ? "," : "");
    }
    printf("]\n");

    // Se libera la memoria
    free(sumF);
    free(sumC);
    mat_destruir(mat, m);

    return 0;
}



Ejercicio 5: Struct + funciones — registro de estudiantes — 15 pts
Enunciado:
Define Estudiante { char nombre[40]; int edad; double promedio; }. Lee n estudiantes, ordénalos por
promedio descendente usando punteros a struct. Implementa búsqueda por nombre.
Firmas/Interfaz sugerida:
typedef struct { char nombre[40]; int edad; double promedio; } Estudiante;
int cmp_prom_desc(const void *a, const void *b);
int buscar_nombre(Estudiante *v, size_t n, const char *clave);
Caso(s) de prueba sugeridos:
2. Imprime el Top-3 por promedio.
3. Permite buscar por nombre exacto y devuelve el índice o -1.


#include <iostream>
#include <cstring>
#include <algorithm>

typedef struct {
    char nombre[40];
    int edad;
    double promedio;
} Estudiante;

int cmp_prom_desc(const void *a, const void *b) {
    double pa = ((Estudiante *)a)->promedio;
    double pb = ((Estudiante *)b)->promedio;
    return (pb > pa) - (pb < pa);  // Orden descendente
}

int buscar_nombre(Estudiante *v, size_t n, const char *clave) {
    for (size_t i = 0; i < n; ++i)
        if (strcmp(v[i].nombre, clave) == 0) return i;
    return -1;
}

int main() {
    size_t n;
    std::cin >> n;
    std::cin.ignore();

    Estudiante *v = new Estudiante[n];

    for (size_t i = 0; i < n; ++i) {
        std::cin.getline(v[i].nombre, 40);
        std::cin >> v[i].edad >> v[i].promedio;
        std::cin.ignore();
    }

    std::qsort(v, n, sizeof(Estudiante), cmp_prom_desc);

    for (size_t i = 0; i < std::min(n, size_t(3)); ++i)
        std::cout << v[i].nombre << " " << std::fixed << std::setprecision(2) << v[i].promedio << "\n";

    char clave[40];
    std::cin.getline(clave, 40);
    int pos = buscar_nombre(v, n, clave);
    std::cout << pos << "\n";

    delete[] v;
    return 0;
}


Ejercicio 6: Lista dinámica simple (memoria dinámica y punteros) — 16 pts
Enunciado:
Implementa una lista enlazada simple de int con operaciones: push_front, push_back, pop_front,
size, clear. Lee comandos desde stdin y ejecuta. Al final imprime el contenido.
• Manejar correctamente malloc/free.
• Usar funciones por operación, sin variables globales.
Firmas/Interfaz sugerida:
typedef struct Nodo { int x; struct Nodo *sig; } Nodo;
Caso(s) de prueba sugeridos:
4. pf 3
5. pf 2
6. pb 9
7. pop
8. pf 7
9. fin → salida: 7 2 9

#include <iostream>
#include <cstring>

typedef struct Nodo {
    int x;
    Nodo *sig;
} Nodo;

void push_front(Nodo **l, int v) {
    Nodo *n = new Nodo{v, *l};
    *l = n;
}

void push_back(Nodo **l, int v) {
    Nodo *n = new Nodo{v, nullptr};
    if (!*l) *l = n;
    else {
        Nodo *p = *l;
        while (p->sig) p = p->sig;
        p->sig = n;
    }
}

void pop_front(Nodo **l) {
    if (*l) {
        Nodo *t = *l;
        *l = t->sig;
        delete t;
    }
}

void clear(Nodo **l) {
    while (*l) pop_front(l);
}

void print(Nodo *l) {
    while (l) {
        std::cout << l->x << " ";
        l = l->sig;
    }
    std::cout << "\n";
}

int main() {
    Nodo *lista = nullptr;
    char cmd[10];
    int val;

    while (std::cin >> cmd) {
        if (!strcmp(cmd, "pf")) std::cin >> val, push_front(&lista, val);
        else if (!strcmp(cmd, "pb")) std::cin >> val, push_back(&lista, val);
        else if (!strcmp(cmd, "pop")) pop_front(&lista);
        else if (!strcmp(cmd, "clear")) clear(&lista);
        else if (!strcmp(cmd, "fin")) break;
    }

    print(lista);
    clear(&lista);
    return 0;
}

Ejercicio 7: Punteros a función (callbacks) — 10 pts
Enunciado:
Implementa aplicar(int *a, size_t n, int (*op)(int)) y dos operaciones: doble, cuadrado. Demuestra su
uso con un menú simple.
Firmas/Interfaz sugerida:
int doble(int x);
int cuadrado(int x);
void aplicar(int *a, size_t n, int (*op)(int));


#include <iostream>

int doble(int x)     { return 2 * x; }
int cuadrado(int x)  { return x * x; }

void aplicar(int *a, size_t n, int (*op)(int)) {
    for (size_t i = 0; i < n; ++i)
        a[i] = op(a[i]);
}

int main() {
    int a[] = {1, 2, 3, 4, 5};
    size_t n = sizeof(a) / sizeof(a[0]);
    int opcion;

    std::cout << "1. Doble\n2. Cuadrado\nOpción: ";
    std::cin >> opcion;

    if (opcion == 1) aplicar(a, n, doble);
    else if (opcion == 2) aplicar(a, n, cuadrado);

    for (size_t i = 0; i < n; ++i)
        std::cout << a[i] << " ";
    std::cout << "\n";

    return 0;
}



Ejercicio 8: Archivo + estructuras — estadísticas de ventas — 10 pts
Enunciado:
Lee un archivo CSV con líneas producto,unidades,precio. Carga a un arreglo dinámico de struct
Venta y calcula total vendido, producto más vendido y ticket promedio.
• Usa punteros, funciones y manejo básico de errores.
Firmas/Interfaz sugerida:
typedef struct { char prod[32]; int unidades; double precio; } Venta;
Caso(s) de prueba sugeridos:
10. CSV corto con 3–5 líneas; valida totales.


#include <iostream>
#include <fstream>
#include <sstream>
#include <vector>
#include <cstring>

typedef struct {
    char prod[32];
    int unidades;
    double precio;
} Venta;

int main() {
    std::ifstream f("ventas.csv");
    if (!f) {
        std::perror("Archivo");
        return 1;
    }

    std::vector<Venta> v;
    std::string linea;

    while (std::getline(f, linea)) {
        std::istringstream ss(linea);
        std::string nombre;
        int unidades;
        double precio;

        if (std::getline(ss, nombre, ',') && ss >> unidades && ss.get() == ',' && ss >> precio) {
            Venta temp;
            std::strncpy(temp.prod, nombre.c_str(), 31);
            temp.prod[31] = '\0';
            temp.unidades = unidades;
            temp.precio = precio;
            v.push_back(temp);
        }
    }

    double total = 0;
    int maxu = -1, imax = -1;
    for (size_t i = 0; i < v.size(); ++i) {
        total += v[i].unidades * v[i].precio;
        if (v[i].unidades > maxu) {
            maxu = v[i].unidades;
            imax = i;
        }
    }

    std::cout << "Total: " << std::fixed << std::setprecision(2) << total << "\n";
    if (imax >= 0) std::cout << "Más vendido: " << v[imax].prod << " (" << v[imax].unidades << ")\n";
    if (!v.empty()) std::cout << "Ticket promedio: " << std::fixed << std::setprecision(2) << total / v.size() << "\n";

    return 0;
}

Bonus (hasta +5 pts): Vector dinámico genérico
Implementa un vector tipo void* con capacidad y tamaño, push_back, get, set y redimensionamiento
por duplicación.

#include <iostream>
#include <cstdlib>
#include <cstring>

struct Vector {
    void* data;
    size_t size;
    size_t cap;
    size_t elem_size;
};

// Crear un nuevo vector
Vector* vec_new(size_t elem_size) {
    Vector* v = new Vector;
    v->size = 0;
    v->cap = 4;
    v->elem_size = elem_size;
    v->data = malloc(v->cap * elem_size);
    return v;
}

// Liberar memoria del vector
void vec_free(Vector* v) {
    free(v->data);
    delete v;
}

// Agregar un elemento al final
void vec_push(Vector* v, const void* elem) {
    if (v->size == v->cap) {
        v->cap *= 2;
        v->data = realloc(v->data, v->cap * v->elem_size);
    }
    std::memcpy((char*)v->data + v->size * v->elem_size, elem, v->elem_size);
    v->size++;
}

// Obtener puntero al elemento en la posición i
void* vec_get(Vector* v, size_t i) {
    if (i >= v->size) return nullptr;
    return (char*)v->data + i * v->elem_size;
}

// Establecer el valor del elemento en la posición i
void vec_set(Vector* v, size_t i, const void* elem) {
    if (i >= v->size) return;
    std::memcpy((char*)v->data + i * v->elem_size, elem, v->elem_size);
}
