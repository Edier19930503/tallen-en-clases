Ejercicio 1: Estadísticas básicas de un arreglo — 10 pts
Enunciado:
Lee n (1 ≤ n ≤ 10^5) y luego n enteros. Calcula mínimo, máximo y promedio (double) usando punteros para recorrer el arreglo. Implementa funciones separar lectura y cálculo.
Firmas/Interfaz sugerida:
void leer_arreglo(int *a, size_t n);
void min_max_prom(const int *a, size_t n, int *minv, int *maxv, double *prom);
Ejemplo:
Entrada: 5\n3 8 -1 4 4 → Salida: min=-1 max=8 prom=3.60


#include <iostream>
#include <iomanip>

void leer_arreglo(int *a, size_t n) {
    for (size_t i = 0; i < n; ++i) {
        std::cin >> *(a + i);
    }
}

void min_max_prom(const int *a, size_t n, int *minv, int *maxv, double *prom) {
    *minv = *maxv = *a;
    long long suma = 0;

    for (const int *p = a; p < a + n; ++p) {
        if (*p < *minv) *minv = *p;
        if (*p > *maxv) *maxv = *p;
        suma += *p;
    }

    *prom = static_cast<double>(suma) / n;
}

int main() {
    size_t n;
    std::cin >> n;

    int *arreglo = new int[n];
    leer_arreglo(arreglo, n);

    int minv, maxv;
    double prom;
    min_max_prom(arreglo, n, &minv, &maxv, &prom);

    std::cout << "min=" << minv
              << " max=" << maxv
              << " prom=" << std::fixed << std::setprecision(2) << prom << '\n';

    delete[] arreglo;
    return 0;
}


Ejercicio 2: Rotación circular in-place — 12 pts Enunciado:
Dado un arreglo de n enteros y un desplazamiento k, rota a la derecha k posiciones in-place. Usa una función auxiliar reverse y punteros.
Firmas/Interfaz sugerida:
void reverse(int *a, size_t i, size_t j);
void rotar_derecha(int *a, size_t n, size_t k);
Caso(s) de prueba sugeridos:
1. [1,2,3,4,5], k=2 → [4,5,1,2,3]



#include <iostream>
using namespace std;

// Función auxiliar: invierte el segmento a[i..j]
void reverse(int *a, size_t i, size_t j) {
    while (i < j) {
        int tmp = *(a + i);
        *(a + i) = *(a + j);
        *(a + j) = tmp;
        i++;
        j--;
    }
}

// Rota el arreglo a la derecha k posiciones
void rotar_derecha(int *a, size_t n, size_t k) {
    if (n == 0) return;
    k = k % n; // evitar rotaciones mayores que n
    if (k == 0) return;

    reverse(a, 0, n - 1);
    reverse(a, 0, k - 1);
    reverse(a, k, n - 1);
}

// Imprimir arreglo
void print_array(int *a, size_t n) {
    for (size_t i = 0; i < n; ++i) {
        cout << *(a + i);
        if (i < n - 1) cout << " ";
    }
    cout << endl;
}

int main() {
    size_t n, k;
    cin >> n >> k;
    int *arr = new int[n];
    for (size_t i = 0; i < n; ++i) cin >> arr[i];

    rotar_derecha(arr, n, k);
    print_array(arr, n);

    delete[] arr;
    return 0;
}


Ejercicio 3: Normalizar cadenas (arreglo de chars) — 12 pts Enunciado:
Lee una línea (≤ 1000 chars) y normalízala: quita espacios duplicados y recorta extremos.
Implementa con punteros (char *src, char *dst) y sin usar strtok.
Firmas/Interfaz sugerida:
size_t normalizar_espacios(const char *in, char *out, size_t outcap);
Ejemplo:
Entrada: " hola mundo C " → Salida: "hola mundo C" (longitud 12)


#include <iostream>
#include <cstring>
using namespace std;

size_t normalizar_espacios(const char *in, char *out, size_t outcap) {
    const char *src = in;
    char *dst = out;
    char *dst_end = out + outcap - 1; // espacio para '\0'

    // Saltar espacios iniciales
    while (*src == ' ') {
        ++src;
    }

    bool espacio_anterior = false;

    while (*src != '\0' && dst < dst_end) {
        if (*src != ' ') {
            *dst++ = *src;
            espacio_anterior = false;
        } else {
            // Encontramos espacio, solo copiamos si el anterior no fue espacio
            if (!espacio_anterior) {
                *dst++ = ' ';
                espacio_anterior = true;
            }
            // si ya hubo espacio antes, no copiamos
        }
        ++src;
    }

    // Eliminar espacio final si existe
    if (dst > out && *(dst - 1) == ' ') {
        --dst;
    }

    *dst = '\0';

    return dst - out; // longitud resultado
}

int main() {
    char entrada[1001];
    char salida[1001];

    cout << "Ingrese una línea: ";
    cin.getline(entrada, 1001);

    size_t longitud = normalizar_espacios(entrada, salida, 1001);

    cout << "Salida: \"" << salida << "\"" << endl;
    cout << "Longitud: " << longitud << endl;

    return 0;
}



Ejercicio 4: Matriz — suma por filas y columnas — 15 pts Enunciado:
Dada una matriz m×n de enteros, calcula dos arreglos: sumFila[m] y sumCol[n]. Usa funciones y
punteros a punteros (int **mat) o representación lineal (int *mat = malloc(m*n*sizeof(int))).
Firmas/Interfaz sugerida:
int **mat_crear(size_t m, size_t n);
void mat_destruir(int **A, size_t m);
void mat_sumas(int **A, size_t m, size_t n, int *sumF, int *sumC);
Ejemplo:
Entrada:
3 4
1 2 3 4
5 6 7 8
9 0 1 2
Salida:
sumF: [10,26,12]
sumC: [15,8,11,14]



#include <iostream>
#include <cstdlib> // malloc, free
using namespace std;

// Crear matriz dinámica m x n
int **mat_crear(size_t m, size_t n) {
    int **mat = (int **)malloc(m * sizeof(int *));
    if (!mat) return nullptr;

    for (size_t i = 0; i < m; ++i) {
        mat[i] = (int *)malloc(n * sizeof(int));
        if (!mat[i]) {
            // liberar memoria en caso de error
            for (size_t j = 0; j < i; ++j) free(mat[j]);
            free(mat);
            return nullptr;
        }
    }
    return mat;
}

// Destruir matriz
void mat_destruir(int **A, size_t m) {
    for (size_t i = 0; i < m; ++i) {
        free(A[i]);
    }
    free(A);
}

// Calcular sumas de filas y columnas
void mat_sumas(int **A, size_t m, size_t n, int *sumF, int *sumC) {
    // Inicializar sumas
    for (size_t i = 0; i < m; ++i) sumF[i] = 0;
    for (size_t j = 0; j < n; ++j) sumC[j] = 0;

    // Sumar
    for (size_t i = 0; i < m; ++i) {
        for (size_t j = 0; j < n; ++j) {
            sumF[i] += A[i][j];
            sumC[j] += A[i][j];
        }
    }
}

int main() {
    size_t m, n;
    cout << "Ingrese filas y columnas: ";
    cin >> m >> n;

    int **mat = mat_crear(m, n);
    if (!mat) {
        cerr << "Error al asignar memoria\n";
        return 1;
    }

    cout << "Ingrese matriz (" << m << "x" << n << "):\n";
    for (size_t i = 0; i < m; ++i) {
        for (size_t j = 0; j < n; ++j) {
            cin >> mat[i][j];
        }
    }

    int *sumF = new int[m];
    int *sumC = new int[n];

    mat_sumas(mat, m, n, sumF, sumC);

    cout << "sumF: [";
    for (size_t i = 0; i < m; ++i) {
        cout << sumF[i];
        if (i < m - 1) cout << ",";
    }
    cout << "]\n";

    cout << "sumC: [";
    for (size_t j = 0; j < n; ++j) {
        cout << sumC[j];
        if (j < n - 1) cout << ",";
    }
    cout << "]\n";

    mat_destruir(mat, m);
    delete[] sumF;
    delete[] sumC;

    return 0;
}




Ejercicio 5: Struct + funciones — registro de estudiantes — 15 pts
Enunciado:
Define Estudiante { char nombre[40]; int edad; double promedio; }. Lee n estudiantes, ordénalos por
promedio descendente usando punteros a struct. Implementa búsqueda por nombre.
Firmas/Interfaz sugerida:
typedef struct { char nombre[40]; int edad; double promedio; } Estudiante;
int cmp_prom_desc(const void *a, const void *b);
int buscar_nombre(Estudiante *v, size_t n, const char *clave);
Caso(s) de prueba sugeridos:
2. Imprime el Top-3 por promedio.
3. Permite buscar por nombre exacto y devuelve el índice o -1.


#include <iostream>
#include <cstring>
#include <cstdlib> // qsort
using namespace std;

// Definición del struct
typedef struct {
    char nombre[40];
    int edad;
    double promedio;
} Estudiante;

// Comparador para qsort: promedio descendente
int cmp_prom_desc(const void *a, const void *b) {
    const Estudiante *ea = (const Estudiante *)a;
    const Estudiante *eb = (const Estudiante *)b;
    if (ea->promedio < eb->promedio) return 1;
    else if (ea->promedio > eb->promedio) return -1;
    else return 0;
}

// Buscar nombre exacto, devuelve índice o -1
int buscar_nombre(Estudiante *v, size_t n, const char *clave) {
    for (size_t i = 0; i < n; ++i) {
        if (strcmp(v[i].nombre, clave) == 0)
            return i;
    }
    return -1;
}

int main() {
    size_t n;
    cout << "Ingrese número de estudiantes: ";
    cin >> n;
    cin.ignore(); // limpiar el buffer de entrada

    Estudiante *est = new Estudiante[n];

    // Leer datos
    for (size_t i = 0; i < n; ++i) {
        cout << "Estudiante " << i+1 << " nombre: ";
        cin.getline(est[i].nombre, 40);
        cout << "Edad: ";
        cin >> est[i].edad;
        cout << "Promedio: ";
        cin >> est[i].promedio;
        cin.ignore(); // limpiar buffer
    }

    // Ordenar por promedio descendente
    qsort(est, n, sizeof(Estudiante), cmp_prom_desc);

    // Imprimir Top-3
    size_t top = n < 3 ? n : 3;
    cout << "\nTop-" << top << " estudiantes por promedio:\n";
    for (size_t i = 0; i < top; ++i) {
        cout << est[i].nombre << " | Edad: " << est[i].edad
             << " | Promedio: " << est[i].promedio << endl;
    }

    // Búsqueda por nombre
    char clave[40];
    cout << "\nIngrese nombre a buscar: ";
    cin.getline(clave, 40);

    int idx = buscar_nombre(est, n, clave);
    if (idx != -1) {
        cout << "Encontrado en índice " << idx << ": "
             << est[idx].nombre << " | Edad: " << est[idx].edad
             << " | Promedio: " << est[idx].promedio << endl;
    } else {
        cout << "No se encontró el estudiante con nombre \"" << clave << "\"\n";
    }

    delete[] est;
    return 0;
}


Ejercicio 6: Lista dinámica simple (memoria dinámica y punteros) — 16 pts
Enunciado:
Implementa una lista enlazada simple de int con operaciones: push_front, push_back, pop_front,
size, clear. Lee comandos desde stdin y ejecuta. Al final imprime el contenido.
• Manejar correctamente malloc/free.
• Usar funciones por operación, sin variables globales.
Firmas/Interfaz sugerida:
typedef struct Nodo { int x; struct Nodo *sig; } Nodo;
Caso(s) de prueba sugeridos:
4. pf 3
5. pf 2
6. pb 9
7. pop
8. pf 7
9. fin → salida: 7 2 9

#include <iostream>
#include <cstring>
#include <cstdlib>
using namespace std;

// Nodo de la lista
typedef struct Nodo {
    int x;
    struct Nodo *sig;
} Nodo;

// Insertar al frente
void push_front(Nodo **head, int val) {
    Nodo *nuevo = (Nodo *)malloc(sizeof(Nodo));
    if (!nuevo) {
        cerr << "Error de memoria\n";
        return;
    }
    nuevo->x = val;
    nuevo->sig = *head;
    *head = nuevo;
}

// Insertar al final
void push_back(Nodo **head, int val) {
    Nodo *nuevo = (Nodo *)malloc(sizeof(Nodo));
    if (!nuevo) {
        cerr << "Error de memoria\n";
        return;
    }
    nuevo->x = val;
    nuevo->sig = nullptr;

    if (*head == nullptr) {
        *head = nuevo;
    } else {
        Nodo *p = *head;
        while (p->sig) p = p->sig;
        p->sig = nuevo;
    }
}

// Eliminar primer nodo
void pop_front(Nodo **head) {
    if (*head == nullptr) return;
    Nodo *tmp = *head;
    *head = (*head)->sig;
    free(tmp);
}

// Tamaño de la lista
size_t size(Nodo *head) {
    size_t cnt = 0;
    while (head) {
        ++cnt;
        head = head->sig;
    }
    return cnt;
}

// Limpiar lista
void clear(Nodo **head) {
    while (*head) {
        pop_front(head);
    }
}

// Imprimir lista
void print_list(Nodo *head) {
    Nodo *p = head;
    while (p) {
        cout << p->x;
        if (p->sig) cout << " ";
        p = p->sig;
    }
    cout << endl;
}

int main() {
    Nodo *head = nullptr;
    char cmd[10];
    int val;

    while (true) {
        cin >> cmd;
        if (strcmp(cmd, "pf") == 0) {
            cin >> val;
            push_front(&head, val);
        } else if (strcmp(cmd, "pb") == 0) {
            cin >> val;
            push_back(&head, val);
        } else if (strcmp(cmd, "pop") == 0) {
            pop_front(&head);
        } else if (strcmp(cmd, "fin") == 0) {
            break;
        } else {
            cerr << "Comando desconocido: " << cmd << endl;
        }
    }

    print_list(head);
    clear(&head);

    return 0;
}




Ejercicio 7: Punteros a función (callbacks) — 10 pts
Enunciado:
Implementa aplicar(int *a, size_t n, int (*op)(int)) y dos operaciones: doble, cuadrado. Demuestra su
uso con un menú simple.
Firmas/Interfaz sugerida:
int doble(int x);
int cuadrado(int x);
void aplicar(int *a, size_t n, int (*op)(int));


#include <iostream>
using namespace std;

// Operaciones
int doble(int x) {
    return 2 * x;
}

int cuadrado(int x) {
    return x * x;
}

// Aplicar función a cada elemento del arreglo
void aplicar(int *a, size_t n, int (*op)(int)) {
    for (size_t i = 0; i < n; ++i) {
        a[i] = op(a[i]);
    }
}

// Imprimir arreglo
void print_array(int *a, size_t n) {
    for (size_t i = 0; i < n; ++i) {
        cout << a[i];
        if (i < n - 1) cout << " ";
    }
    cout << endl;
}

int main() {
    size_t n;
    cout << "Ingrese tamaño del arreglo: ";
    cin >> n;

    int *arr = new int[n];
    cout << "Ingrese elementos:\n";
    for (size_t i = 0; i < n; ++i) {
        cin >> arr[i];
    }

    int opcion;
    cout << "\nMenú:\n1. Doble\n2. Cuadrado\nElija opción: ";
    cin >> opcion;

    if (opcion == 1) {
        aplicar(arr, n, doble);
    } else if (opcion == 2) {
        aplicar(arr, n, cuadrado);
    } else {
        cout << "Opción no válida.\n";
    }

    cout << "Arreglo resultante:\n";
    print_array(arr, n);

    delete[] arr;
    return 0;
}




Ejercicio 8: Archivo + estructuras — estadísticas de ventas — 10 pts
Enunciado:
Lee un archivo CSV con líneas producto,unidades,precio. Carga a un arreglo dinámico de struct
Venta y calcula total vendido, producto más vendido y ticket promedio.
• Usa punteros, funciones y manejo básico de errores.
Firmas/Interfaz sugerida:
typedef struct { char prod[32]; int unidades; double precio; } Venta;
Caso(s) de prueba sugeridos:
10. CSV corto con 3–5 líneas; valida totales.


#include <iostream>
#include <fstream>
#include <sstream>
#include <cstring>
#include <cstdlib>
using namespace std;

typedef struct {
    char prod[32];
    int unidades;
    double precio;
} Venta;

// Cargar ventas desde archivo CSV
size_t cargar_ventas(const char *filename, Venta **arr) {
    ifstream file(filename);
    if (!file.is_open()) {
        cerr << "Error al abrir archivo " << filename << endl;
        return 0;
    }

    size_t capacidad = 10;
    size_t n = 0;
    *arr = (Venta *)malloc(capacidad * sizeof(Venta));
    if (!*arr) {
        cerr << "Error de memoria\n";
        return 0;
    }

    string linea;
    while (getline(file, linea)) {
        if (n >= capacidad) {
            capacidad *= 2;
            *arr = (Venta *)realloc(*arr, capacidad * sizeof(Venta));
            if (!*arr) {
                cerr << "Error de memoria\n";
                return n;
            }
        }

        stringstream ss(linea);
        string campo;
        // Leer producto
        if (!getline(ss, campo, ',')) continue;
        strncpy((*arr)[n].prod, campo.c_str(), 31);
        (*arr)[n].prod[31] = '\0';

        // Leer unidades
        if (!getline(ss, campo, ',')) continue;
        (*arr)[n].unidades = atoi(campo.c_str());

        // Leer precio
        if (!getline(ss, campo, ',')) continue;
        (*arr)[n].precio = atof(campo.c_str());

        n++;
    }

    file.close();
    return n;
}

// Calcular estadísticas
void estadisticas(Venta *arr, size_t n, double &total, char *mas_vendido, double &ticket_prom) {
    total = 0;
    ticket_prom = 0;
    int max_unidades = -1;
    for (size_t i = 0; i < n; ++i) {
        total += arr[i].unidades * arr[i].precio;
        ticket_prom += arr[i].precio;
        if (arr[i].unidades > max_unidades) {
            max_unidades = arr[i].unidades;
            strncpy(mas_vendido, arr[i].prod, 31);
            mas_vendido[31] = '\0';
        }
    }
    ticket_prom = n > 0 ? ticket_prom / n : 0;
}

int main() {
    const char *filename = "ventas.csv"; // Cambiar al nombre del archivo
    Venta *ventas = nullptr;

    size_t n = cargar_ventas(filename, &ventas);
    if (n == 0) {
        cout << "No se cargaron ventas.\n";
        return 1;
    }

    double total, ticket_prom;
    char mas_vendido[32];
    estadisticas(ventas, n, total, mas_vendido, ticket_prom);

    cout << "Total vendido: " << total << endl;
    cout << "Producto más vendido: " << mas_vendido << endl;
    cout << "Ticket promedio: " << ticket_prom << endl;

    free(ventas);
    return 0;
}


Bonus (hasta +5 pts): Vector dinámico genérico
Implementa un vector tipo void* con capacidad y tamaño, push_back, get, set y redimensionamiento
por duplicación.

#include <iostream>
#include <cstdlib>
#include <cstring>

struct Vector {
    void* data;
    size_t size;
    size_t cap;
    size_t elem_size;
};

Vector* vec_new(size_t elem_size) {
    Vector* v = (Vector*)std::malloc(sizeof(Vector));
    if (!v) return nullptr;

    v->size = 0;
    v->cap = 4;
    v->elem_size = elem_size;
    v->data = std::malloc(v->cap * elem_size);
    if (!v->data) {
        std::free(v);
        return nullptr;
    }
    return v;
}

void vec_free(Vector* v) {
    if (!v) return;
    std::free(v->data);
    std::free(v);
}

void vec_push(Vector* v, const void* elem) {
    if (v->size == v->cap) {
        v->cap *= 2;
        void* tmp = std::realloc(v->data, v->cap * v->elem_size);
        if (!tmp) return;
        v->data = tmp;
    }
    std::memcpy((char*)v->data + v->size * v->elem_size, elem, v->elem_size);
    v->size++;
}

void* vec_get(const Vector* v, size_t i) {
    if (i >= v->size) return nullptr;
    return (char*)v->data + i * v->elem_size;
}

void vec_set(Vector* v, size_t i, const void* elem) {
    if (i >= v->size) return;
    std::memcpy((char*)v->data + i * v->elem_size, elem, v->elem_size);
}

// agregamos una función main de prueba
int main() {
    Vector* v = vec_new(sizeof(int));

    for (int i = 0; i < 10; ++i) {
        vec_push(v, &i);
    }

    std::cout << "Vector contents:\n";
    for (size_t i = 0; i < v->size; ++i) {
        int* val = (int*)vec_get(v, i);
        std::cout << *val << " ";
    }
    std::cout << std::endl;

    vec_free(v);
    return 0;
}
